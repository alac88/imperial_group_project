open Core


let batch_size = 10

let get_query vulnerability_type = match vulnerability_type with
  | "integer-overflow" -> "is_overflow"
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let make_connection () = PgDb.create (Sys.getenv_exn "DATABASE_URL")

let analyze_contracts ~file ~vulnerability_type contracts =
  let open PgMonad.Let_syntax in
  let tracer = Tracer.create Taggers.all in

  let total_count = List.length contracts in

  let%bind connection_pool = PgMonad.all (List.init ~f:(fun _ -> make_connection ()) batch_size) in
  let get_db i = List.nth_exn connection_pool i in

  let analyze_transaction raw_trace =
    let trace = Yojson.Safe.from_string raw_trace in
    let struct_logs = Yojson.Safe.Util.member "structLogs" trace in
    let traces = TraceParser.parse_json struct_logs in
    let db = Tracer.execute_traces tracer traces in
    let trace_indexes = FactDb.query1 db (get_query vulnerability_type) in
    List.map ~f:(Fn.flip Yojson.Safe.Util.index struct_logs) trace_indexes
  in

  let transform_transaction (hash, traces) =
    try
      (hash, analyze_transaction traces)
    with e ->
      Logs.err (fun m -> m "%s failed: %s" hash (Exn.to_string e));
      (hash, [])
  in

  let analyze_contract index contract =
    let pg_db = get_db index in
    let rec run_analysis offset acc =
      let%bind transactions = PgDb.get_contract_transactions pg_db ~offset contract in
      if List.is_empty transactions
        then PgMonad.return []
        else
          let results =
            transactions |> List.map ~f:transform_transaction
            |> List.filter ~f:(fun (_, t) -> not (List.is_empty t))
          in
          run_analysis (offset + List.length transactions) (acc @ results)
    in
    let%map result = run_analysis 0 [] in
    let json = `Assoc [("address", `String contract); ("result", `Assoc result)] in
    Lwt_io.fprintf file "%s\n" (Yojson.Safe.to_string json)
  in

  let rec run_full_analysis contracts i acc =
    Logs.info (fun m -> m "progress: %d/%d" i total_count);

    match contracts with
    | [] -> PgMonad.return (List.rev acc)
    | contracts_list ->
      let (batch, rest) = List.split_n contracts_list batch_size in
      let%bind results = PgMonad.all (List.mapi ~f:analyze_contract batch) in
      run_full_analysis rest (i + (List.length batch)) (results @ acc)
  in
  run_full_analysis contracts 0 []


let analyze_vulnerabilities vulnerability_type ~output =
  let open PgMonad.Let_syntax in

  let%bind pg_db = make_connection () in
  let%bind contracts = PgDb.get_vulnerable_contracts pg_db vulnerability_type in
  let%bind () = PgDb.disconnect pg_db in

  let total_count = List.length contracts in
  Logs.info (fun m -> m "analyzing %d contracts" total_count);

  let run file = analyze_contracts ~file ~vulnerability_type contracts in

  PgMonad.ignore_m (Lwt_io.with_file ~mode:Lwt_io.Output output run)
