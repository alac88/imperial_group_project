open Core


let batch_size = 20

let get_query vulnerability_type = match vulnerability_type with
  | "integer-overflow" -> "is_overflow"
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let analyze_vulnerabilities vulnerability_type ~output =
  let open PgMonad.Let_syntax in
  let make_connection () = PgDb.create (Sys.getenv_exn "DATABASE_URL") in
  let%bind connection_pool = PgMonad.all (List.init ~f:(fun _ -> make_connection ()) batch_size) in
  let get_db i = List.nth_exn connection_pool i in

  let%bind contracts = PgDb.get_vulnerable_contracts (get_db 0) vulnerability_type in

  let total_count = List.length contracts in
  Logs.info (fun m -> m "analyzing %d contracts" total_count);

  let tracer = Tracer.create Taggers.all in

  let analyze_transaction raw_trace =
    let trace = Yojson.Safe.from_string raw_trace in
    let struct_logs = Yojson.Safe.Util.member "structLogs" trace in
    let traces = TraceParser.parse_json struct_logs in
    let db = Tracer.execute_traces tracer traces in
    let trace_indexes = FactDb.query1 db (get_query vulnerability_type) in
    List.map ~f:(Fn.flip Yojson.Safe.Util.index struct_logs) trace_indexes
  in

  let transform_transaction (hash, traces) =
    try
      (hash, analyze_transaction traces)
    with e ->
      Logs.err (fun m -> m "%s failed: %s" hash (Exn.to_string e));
      (hash, [])
  in

  let analyze_contract index contract =
    let pg_db = get_db index in
    let rec run_analysis offset acc =
      let%bind transactions = PgDb.get_contract_transactions pg_db ~offset contract in
      if List.is_empty transactions
        then PgMonad.return []
        else
          let results =
            transactions |> List.map ~f:transform_transaction
            |> List.filter ~f:(fun (_, t) -> not (List.is_empty t))
          in
          run_analysis (offset + List.length transactions) (acc @ results)
    in
    run_analysis 0 []
  in

  let rec analyze_contracts contracts i acc =
    Logs.info (fun m -> m "progress: %d/%d" i total_count);

    match contracts with
    | [] -> PgMonad.return (List.rev acc)
    | contracts_list ->
      let (batch, rest) = List.split_n contracts_list batch_size in
      let%bind results = PgMonad.all (List.mapi ~f:analyze_contract batch) in
      analyze_contracts rest (i + (List.length batch)) (results @ acc)
  in

  let%map results = analyze_contracts contracts 0 [] in

  let vulnerable_results =
    List.zip_exn contracts results
    |> List.filter ~f:(fun (_, v) -> not (List.is_empty v))
    |> List.map ~f:(fun (t, v) -> `Assoc [("address", `String t); ("result", `Assoc v)])
  in
  let output_to_file out =
    let make_line v = Yojson.Safe.to_string v ^ "\n" in
    let f v = Out_channel.output_string out (make_line v) in
    List.iter ~f vulnerable_results
  in
  Out_channel.with_file output ~f:output_to_file
