open Core


let timeout = 120.
let batch_size = 10

let json_traces indexes ~struct_logs =
  `List (List.map ~f:(Fn.flip Yojson.Safe.Util.index struct_logs) indexes)

let get_reentrant_calls db =
  `List (List.map ~f:ReentrantCall.to_json (ReentrantCall.aggregate_calls db))

let get_tod_txs db =
  let tod_txs = FactDb.query3 db FactDb.Relations.tod in
  let f (b, tx1, tx2) = `Assoc [("block", `Int b); ("tx1", `String tx1); ("tx2", `String tx2)] in
  `List (List.map ~f tod_txs)

let get_empty_delegates db =
  let empty_delegate = FactDb.get_rel1 ~k:FactDb.Types.bigint_key "empty_delegate" in
  let result = FactDb.query1 db empty_delegate in
  let f address = `String (BigInt.to_hex ~length:40 address) in
  `List (List.map ~f result)

let get_final_results db vulnerability_type =
  match vulnerability_type with
  | "tod" -> get_tod_txs db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let get_results db ~struct_logs vulnerability_type =
  let module T = FactDb.Types in

  let get_logs query =
    FactDb.query1 db (FactDb.get_rel1 ~k:T.int query) |> json_traces ~struct_logs
  in

  match vulnerability_type with
  | "integer-overflow" -> get_logs "is_overflow"
  | "unhandled-exception" -> get_logs "unhandled_exception"
  | "locked-ether" -> get_empty_delegates db
  | "reentrancy" -> get_reentrant_calls db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let make_connection () = PgDb.create (Sys.getenv_exn "DATABASE_URL")

let analyze_contracts ~file ~vulnerability_type contracts =
  let open PgMonad.Let_syntax in

  let include_indirect_transactions = match vulnerability_type with
  | "reentrancy" -> true
  | _ -> false
  in

  let get_initial_db () = match vulnerability_type with
  | "tod" -> Some (FactDb.create ())
  | _     -> None
  in

  let per_contract = match vulnerability_type with
  | "tod" -> false
  | _ -> true
  in

  let taggers = Taggers.for_vulnerability vulnerability_type in

  let total_count = List.length contracts in

  let%bind connection_pool = PgMonad.all (List.init ~f:(fun _ -> make_connection ()) batch_size) in
  let get_db i = List.nth_exn connection_pool i in

  let analyze_transaction ~db ~tracer raw_trace =
    let trace = Yojson.Safe.from_string raw_trace in
    let struct_logs = Yojson.Safe.Util.member "structLogs" trace in
    let traces = TraceParser.parse_json struct_logs in
    let db = Tracer.execute_traces ?db tracer traces in
    if per_contract
      then get_results db ~struct_logs vulnerability_type
      else `List []
  in

  let trace_transaction db (tx_hash, traces, address, block_number) =
    let tracer = Tracer.create ~tx_hash ~taggers ~block_number address in
    try
      let result = analyze_transaction ~db ~tracer traces in
      (tx_hash, result)
    with e ->
      Logs.err (fun m -> m "%s failed: %s" tx_hash (Exn.to_string e));
      (tx_hash, `List [])
  in

  let analyze_contract index contract =
    let start = Unix.gettimeofday () in
    let pg_db = get_db index in
    let fact_db = get_initial_db () in
    let rec run_analysis offset acc =
      let%bind transactions =
        PgDb.get_contract_transactions pg_db
            ~include_indirect:include_indirect_transactions ~offset contract in
      let ellapsed_time = Unix.gettimeofday () -. start in
      let has_timeout = ellapsed_time > timeout in
      if List.is_empty transactions || has_timeout
        then PgMonad.return (acc, has_timeout)
        else
          let not_list_empty (_, t) = not (List.is_empty (Yojson.Safe.Util.to_list t)) in
          let results =
            transactions |> List.map ~f:(trace_transaction fact_db)
            |> List.filter ~f:not_list_empty
          in
          run_analysis (offset + List.length transactions) (acc @ results)
    in
    let%bind (result, has_timeout) = run_analysis 0 [] in
    let json_result =
      if per_contract
        then `Assoc result
        else get_final_results (Option.value_exn fact_db) vulnerability_type
    in
    let json = `Assoc [("address", `String contract);
                       ("result", json_result);
                       ("timeout", `Bool has_timeout)] in
    PgMonad.lift (Lwt_io.fprintf file "%s\n" (Yojson.Safe.to_string json))
  in

  let rec run_full_analysis contracts i acc =
    Logs.info (fun m -> m "progress: %d/%d" i total_count);

    match contracts with
    | [] -> PgMonad.return (List.rev acc)
    | contracts_list ->
      let (batch, rest) = List.split_n contracts_list batch_size in
      let%bind results = PgMonad.all (List.mapi ~f:analyze_contract batch) in
      run_full_analysis rest (i + (List.length batch)) (results @ acc)
  in
  run_full_analysis contracts 0 []

let remove_checked_contracts contracts output = match Sys.file_exists output with
  | `No | `Unknown -> contracts
  | `Yes ->
    let open Yojson.Safe.Util in
    let get_address line = line |> Yojson.Safe.from_string |> member "address" |> to_string in
    let existing = List.map ~f:get_address (In_channel.read_lines output) |> String.Set.of_list in
    let exists contract = Set.exists ~f:((=) contract) existing in
    List.filter contracts ~f:(Fn.compose not exists)

let analyze_vulnerabilities ?addresses vulnerability_type ~output =
  let open PgMonad.Let_syntax in

  let%bind pg_db = make_connection () in
  let%bind contracts = match addresses with
  | Some v -> PgMonad.return v
  | None -> PgDb.get_vulnerable_contracts pg_db vulnerability_type
  in
  let%bind () = PgDb.disconnect pg_db in
  let unchecked_contracts = remove_checked_contracts contracts output in

  let total_count = List.length unchecked_contracts in
  Logs.info (fun m -> m "analyzing %d contracts" total_count);

  let run file = analyze_contracts ~file ~vulnerability_type unchecked_contracts in

  let flags = [Unix.O_APPEND; Unix.O_CREAT; Unix.O_WRONLY; Unix.O_CLOEXEC] in
  PgMonad.ignore_m (Lwt_io.with_file ~flags ~mode:Lwt_io.Output output run)
